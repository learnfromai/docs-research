# DAST Analysis: Dynamic Application Security Testing

## üéØ Overview

Dynamic Application Security Testing (DAST) analyzes running applications to identify security vulnerabilities by simulating real-world attacks. Unlike SAST, DAST tests the application from the outside, providing a hacker's perspective on potential security flaws. This analysis focuses on DAST tools and methodologies specifically relevant to educational technology platforms.

## üîç DAST Fundamentals

### How DAST Works

**Testing Process:**
1. **Application Discovery**: Maps application structure and endpoints
2. **Attack Simulation**: Sends malicious payloads to test inputs
3. **Response Analysis**: Analyzes application responses for vulnerabilities
4. **Business Logic Testing**: Tests complex application workflows
5. **Authentication Testing**: Validates access controls and session management
6. **Report Generation**: Provides actionable vulnerability reports

**Key Advantages:**
- **Real-world Testing**: Tests actual running application
- **No Source Code Required**: Black-box testing approach
- **Runtime Vulnerabilities**: Detects configuration and deployment issues
- **Business Logic Flaws**: Identifies complex workflow vulnerabilities
- **Third-party Integration**: Tests complete application stack

**Limitations:**
- **Code Coverage**: Cannot test all code paths
- **Environment Dependent**: Results vary by deployment environment
- **False Positives**: May flag intended application behavior
- **Performance Impact**: Can affect application performance during testing

## üèÜ Leading DAST Tools Deep Dive

### 1. OWASP ZAP - Comprehensive Free Solution

#### Architecture and Setup

**ZAP Automation Framework:**
```yaml
# zap-automation-config.yml
env:
  contexts:
    - name: "EdTech Platform - Student Portal"
      urls:
        - "https://staging.edtech-platform.com"
      includePaths:
        - "https://staging.edtech-platform.com/api/.*"
        - "https://staging.edtech-platform.com/student/.*"
        - "https://staging.edtech-platform.com/courses/.*"
      excludePaths:
        - "https://staging.edtech-platform.com/admin/.*"
        - "https://staging.edtech-platform.com/static/.*"
        - "https://staging.edtech-platform.com/assets/.*"
      
      authentication:
        method: "json"
        loginUrl: "https://staging.edtech-platform.com/api/auth/login"
        loginRequestData: |
          {
            "email": "{%username%}",
            "password": "{%password%}"
          }
        usernameParameter: "email"
        passwordParameter: "password"
        loginPageUrl: "https://staging.edtech-platform.com/login"
        loggedInRegex: '"authenticated":\s*true'
        loggedOutRegex: '"authenticated":\s*false'
      
      sessionManagement:
        method: "cookie"
        sessionTokens:
          - "connect.sid"
          - "csrf-token"
      
      users:
        - name: "student_user"
          username: "test.student@edtech.com"
          password: "TestPassword123!"
          
        - name: "teacher_user"
          username: "test.teacher@edtech.com"
          password: "TeacherPass456!"

jobs:
  - type: "spider"
    parameters:
      context: "EdTech Platform - Student Portal"
      user: "student_user"
      maxDuration: 10
      maxDepth: 5
      acceptCookies: true
      handleParameters: true
      parseComments: true
      parseRobotsTxt: true
      parseSitemapXml: true
      
  - type: "activeScan"
    parameters:
      context: "EdTech Platform - Student Portal"
      user: "student_user"
      policy: "EdTech-Security-Policy"
      maxDuration: 30
      maxRuleDurationInMins: 2
      maxScanDurationInMins: 30
      addQueryParam: false
      defaultStrength: "MEDIUM"
      delayInMs: 0
      handleAntiCSRFTokens: true
      injectPluginIdInHeader: false
      scanHeadersAllRequests: false
      threadPerHost: 2
      
  - type: "passiveScan-wait"
    parameters:
      maxDuration: 5
      
  - type: "report"
    parameters:
      template: "traditional-html"
      reportDir: "/tmp/zap-reports"
      reportFile: "edtech-security-report"
      reportTitle: "EdTech Platform Security Assessment"
      reportDescription: "DAST security scan results for educational platform"
```

**Custom ZAP Scripts for EdTech:**
```python
# zap-scripts/edtech-grade-manipulation-test.py
"""
EdTech specific script to test grade manipulation vulnerabilities
"""

def scan(ps, msg, src):
    """
    Test for grade manipulation vulnerabilities
    """
    # Get the original message
    original_uri = msg.getRequestHeader().getURI().toString()
    
    # Check if this is a grade-related endpoint
    if any(keyword in original_uri.lower() for keyword in ['grade', 'score', 'assessment', 'exam']):
        
        # Test for privilege escalation in grade updates
        if msg.getRequestHeader().getMethod() in ['PUT', 'POST', 'PATCH']:
            test_grade_privilege_escalation(ps, msg, src)
            
        # Test for grade tampering via parameter manipulation
        test_grade_parameter_manipulation(ps, msg, src)
        
        # Test for grade viewing authorization
        test_grade_viewing_authorization(ps, msg, src)

def test_grade_privilege_escalation(ps, msg, src):
    """Test if users can modify grades they shouldn't have access to"""
    
    # Create test payloads for different user roles
    payloads = [
        '{"student_id": "other_student_123", "grade": "A+"}',
        '{"course_id": "unauthorized_course", "grade": "100"}',
        '{"grade": "999", "override": true}'
    ]
    
    for payload in payloads:
        # Create new message with malicious payload
        new_msg = msg.cloneRequest()
        new_msg.setRequestBody(payload)
        
        # Send the request
        ps.sendAndReceive(new_msg, False)
        
        # Analyze response
        response_body = new_msg.getResponseBody().toString()
        response_code = new_msg.getResponseHeader().getStatusCode()
        
        # Check for successful grade manipulation
        if response_code == 200 and any(success_indicator in response_body.lower() 
                                      for success_indicator in ['success', 'updated', 'saved']):
            
            # Raise alert
            ps.raiseAlert(
                risk=3,  # High risk
                confidence=2,  # Medium confidence
                name="Grade Manipulation Vulnerability",
                description=f"Application allows unauthorized grade modifications. Payload: {payload}",
                uri=new_msg.getRequestHeader().getURI().toString(),
                param="grade",
                attack=payload,
                otherInfo="Users may be able to modify grades for other students or courses",
                solution="Implement proper authorization checks for grade modifications",
                reference="https://owasp.org/www-project-top-ten/2017/A5_2017-Broken_Access_Control",
                evidence=response_body[:200],
                cweId=639,  # Authorization Bypass Through User-Controlled Key
                wascId=2    # Insufficient Authorization
            )

def test_grade_parameter_manipulation(ps, msg, src):
    """Test for grade tampering via parameter manipulation"""
    
    # Extract parameters from the request
    params = msg.getRequestHeader().getURIParams()
    
    for param in params:
        if any(grade_keyword in param.getName().lower() 
               for grade_keyword in ['grade', 'score', 'points', 'mark']):
            
            # Test with extreme values
            extreme_values = ['9999', '-1', 'A+++', '‚àû', 'null', 'undefined']
            
            for value in extreme_values:
                # Create modified request
                modified_msg = msg.cloneRequest()
                modified_params = modified_msg.getRequestHeader().getURIParams()
                
                # Replace parameter value
                for i, p in enumerate(modified_params):
                    if p.getName() == param.getName():
                        modified_params[i] = HTTPParam(param.getName(), value)
                
                # Send modified request
                ps.sendAndReceive(modified_msg, False)
                
                # Check for successful manipulation
                response = modified_msg.getResponseBody().toString()
                if '200' in str(modified_msg.getResponseHeader().getStatusCode()):
                    if value in response or 'success' in response.lower():
                        ps.raiseAlert(
                            risk=2,  # Medium risk
                            confidence=2,  # Medium confidence
                            name="Grade Parameter Manipulation",
                            description=f"Grade parameter accepts invalid value: {value}",
                            uri=modified_msg.getRequestHeader().getURI().toString(),
                            param=param.getName(),
                            attack=value,
                            solution="Implement proper input validation for grade parameters"
                        )
```

**Advanced ZAP Configuration:**
```xml
<!-- zap-policies/edtech-security-policy.policy -->
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<configuration>
    <policy>EdTech-Security-Policy</policy>
    <scanner>
        <!-- Authentication Testing -->
        <strength>MEDIUM</strength>
        <threshold>MEDIUM</threshold>
        <enabled>true</enabled>
        
        <!-- SQL Injection - High priority for EdTech -->
        <scannerinfo>
            <id>40018</id>
            <enabled>true</enabled>
            <strength>HIGH</strength>
            <threshold>LOW</threshold>
        </scannerinfo>
        
        <!-- XSS - Critical for educational platforms -->
        <scannerinfo>
            <id>40012</id>
            <enabled>true</enabled>
            <strength>HIGH</strength>
            <threshold>LOW</threshold>
        </scannerinfo>
        
        <!-- CSRF - Important for grade modifications -->
        <scannerinfo>
            <id>20012</id>
            <enabled>true</enabled>
            <strength>HIGH</strength>
            <threshold>LOW</threshold>
        </scannerinfo>
        
        <!-- Directory Traversal - Protect student files -->
        <scannerinfo>
            <id>6</id>
            <enabled>true</enabled>
            <strength>MEDIUM</strength>
            <threshold>MEDIUM</threshold>
        </scannerinfo>
        
        <!-- Authorization Testing -->
        <scannerinfo>
            <id>10101</id>
            <enabled>true</enabled>
            <strength>HIGH</strength>
            <threshold>LOW</threshold>
        </scannerinfo>
    </scanner>
</configuration>
```

#### CI/CD Integration

**GitHub Actions Workflow:**
```yaml
# .github/workflows/dast-zap.yml
name: DAST Security Scan with ZAP

on:
  schedule:
    - cron: '0 2 * * 1'  # Weekly Monday 2 AM
  workflow_dispatch:
    inputs:
      target_url:
        description: 'Target URL to scan'
        required: true
        default: 'https://staging.edtech-platform.com'
      scan_type:
        description: 'Scan type'
        required: true
        default: 'baseline'
        type: choice
        options:
          - baseline
          - full
          - api

jobs:
  dast-scan:
    runs-on: ubuntu-latest
    permissions:
      security-events: write
      
    services:
      # Start the application for testing
      app:
        image: edtech-platform:staging
        ports:
          - 3000:3000
        env:
          NODE_ENV: staging
          DATABASE_URL: ${{ secrets.STAGING_DATABASE_URL }}
        options: >-
          --health-cmd "curl -f http://localhost:3000/health || exit 1"
          --health-interval 30s
          --health-timeout 10s
          --health-retries 5
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Setup test data
      run: |
        # Wait for application to be ready
        sleep 30
        
        # Create test users and data
        curl -X POST http://localhost:3000/api/test/setup \
          -H "Content-Type: application/json" \
          -d '{"action": "create_test_data"}'
    
    - name: ZAP Baseline Scan
      if: github.event.inputs.scan_type == 'baseline' || github.event.inputs.scan_type == ''
      uses: zaproxy/action-baseline@v0.10.0
      with:
        target: ${{ github.event.inputs.target_url || 'http://localhost:3000' }}
        rules_file_name: '.security/zap-rules.tsv'
        cmd_options: '-a -j -m 10 -T 60 -z "-configFile /zap/wrk/zap-automation-config.yml"'
        
    - name: ZAP Full Scan
      if: github.event.inputs.scan_type == 'full'
      uses: zaproxy/action-full-scan@v0.10.0
      with:
        target: ${{ github.event.inputs.target_url || 'http://localhost:3000' }}
        rules_file_name: '.security/zap-rules.tsv'
        cmd_options: '-a -j -m 10 -T 180 -z "-configFile /zap/wrk/zap-automation-config.yml"'
        
    - name: ZAP API Scan
      if: github.event.inputs.scan_type == 'api'
      uses: zaproxy/action-api-scan@v0.7.0
      with:
        target: ${{ github.event.inputs.target_url || 'http://localhost:3000' }}
        format: openapi
        api_spec: './docs/api-spec.yml'
        cmd_options: '-a -j -T 60'
    
    - name: Convert ZAP Report to SARIF
      run: |
        # Install ZAP to SARIF converter
        pip install zaproxy-sarif-converter
        
        # Convert ZAP JSON report to SARIF
        zap-to-sarif -i report_json.json -o zap-results.sarif
    
    - name: Upload SARIF results
      uses: github/codeql-action/upload-sarif@v3
      with:
        sarif_file: zap-results.sarif
      if: always()
    
    - name: Generate Security Report
      run: |
        # Generate comprehensive security report
        python scripts/generate-dast-report.py \
          --zap-json report_json.json \
          --output security-report.md \
          --target ${{ github.event.inputs.target_url || 'http://localhost:3000' }}
    
    - name: Upload Security Report
      uses: actions/upload-artifact@v4
      with:
        name: dast-security-report
        path: |
          security-report.md
          report_html.html
          report_json.json
        retention-days: 30
    
    - name: Post Results to PR
      if: github.event_name == 'pull_request'
      uses: actions/github-script@v7
      with:
        script: |
          const fs = require('fs');
          
          if (fs.existsSync('security-report.md')) {
            const report = fs.readFileSync('security-report.md', 'utf8');
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `## üîç DAST Security Scan Results\n\n${report}`
            });
          }
```

### 2. Nuclei - Fast Template-Based Scanner

#### Template Development

**EdTech Specific Templates:**
```yaml
# nuclei-templates/edtech-vulnerabilities.yml
id: edtech-grade-manipulation

info:
  name: Grade Manipulation Test
  author: security-team
  severity: high
  description: Tests for grade manipulation vulnerabilities in educational platforms
  classification:
    cvss-metrics: CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:H/A:N
    cvss-score: 6.5
    cwe-id: CWE-639
  tags: edtech,grades,authorization

requests:
  - method: POST
    path:
      - "{{BaseURL}}/api/grades/update"
      - "{{BaseURL}}/api/student/grades"
      - "{{BaseURL}}/grades/modify"
    
    headers:
      Content-Type: "application/json"
      Authorization: "Bearer {{token}}"
    
    body: |
      {
        "student_id": "{{student_id}}",
        "course_id": "{{course_id}}",
        "grade": "A+",
        "points": 100,
        "override": true
      }
    
    matchers-condition: and
    matchers:
      - type: status
        status:
          - 200
          - 201
      
      - type: word
        words:
          - "success"
          - "updated"
          - "modified"
        condition: or
        part: body
    
    extractors:
      - type: json
        json:
          - '.message'
          - '.grade'
          - '.student_id'

---

id: edtech-student-pii-exposure

info:
  name: Student PII Exposure
  author: security-team
  severity: critical
  description: Tests for student personally identifiable information exposure
  tags: edtech,pii,privacy,gdpr

requests:
  - method: GET
    path:
      - "{{BaseURL}}/api/students"
      - "{{BaseURL}}/api/students/{{student_id}}"
      - "{{BaseURL}}/students/profile"
    
    headers:
      Authorization: "Bearer {{token}}"
    
    matchers-condition: and
    matchers:
      - type: status
        status:
          - 200
      
      - type: regex
        regex:
          - '[0-9]{3}-[0-9]{2}-[0-9]{4}'  # SSN pattern
          - '[0-9]{16}'                    # Credit card pattern
          - 'social_security'
          - 'date_of_birth'
        condition: or
        part: body
    
    extractors:
      - type: regex
        regex:
          - 'ssn["\s]*:["\s]*([0-9-]+)'
          - 'social_security["\s]*:["\s]*([0-9-]+)'
        group: 1

---

id: edtech-course-access-bypass

info:
  name: Course Access Control Bypass
  author: security-team
  severity: high
  description: Tests for unauthorized course access
  tags: edtech,authorization,courses

requests:
  - method: GET
    path:
      - "{{BaseURL}}/api/courses/premium/{{course_id}}"
      - "{{BaseURL}}/courses/{{course_id}}/content"
      - "{{BaseURL}}/premium-content/{{course_id}}"
    
    headers:
      Authorization: "Bearer {{free_user_token}}"
    
    matchers-condition: and
    matchers:
      - type: status
        status:
          - 200
      
      - type: word
        words:
          - "course_content"
          - "video_url"
          - "premium_material"
          - "lesson_content"
        condition: or
        part: body
    
    extractors:
      - type: json
        json:
          - '.course_title'
          - '.content_type'
          - '.access_level'
```

**Advanced Nuclei Configuration:**
```yaml
# nuclei-config.yml
# Nuclei configuration for EdTech platform testing

# DNS Configuration
dns:
  - 8.8.8.8
  - 1.1.1.1

# HTTP Configuration
http:
  max-redirects: 10
  max-response-size: 10MB
  timeout: 10
  retries: 1
  
# Rate limiting
rate-limit: 100
bulk-size: 25
concurrency: 25

# Templates configuration
templates:
  - nuclei-templates/
  - custom-templates/edtech/
  
# Exclusions
exclude-templates:
  - nuclei-templates/dos/
  - nuclei-templates/fuzzing/

# Filters
severity: 
  - info
  - low
  - medium
  - high
  - critical

tags:
  - edtech
  - owasp-top-10
  - cve
  - exposure

# Output configuration
output: nuclei-results.txt
json: nuclei-results.json
sarif: nuclei-results.sarif

# Variables for EdTech testing
variables:
  student_id: test_student_123
  teacher_id: test_teacher_456  
  course_id: course_789
  free_user_token: eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9...
  premium_user_token: eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9...
```

#### GitHub Actions Integration

```yaml
# .github/workflows/nuclei-scan.yml
name: Nuclei Security Scan

on:
  schedule:
    - cron: '0 1 * * *'  # Daily at 1 AM
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  nuclei-scan:
    runs-on: ubuntu-latest
    permissions:
      security-events: write
      
    steps:
    - name: Checkout
      uses: actions/checkout@v4
    
    - name: Setup Nuclei
      uses: projectdiscovery/nuclei-action@main
      with:
        target: https://staging.edtech-platform.com
        templates: |
          nuclei-templates/
          custom-templates/edtech/
        config: nuclei-config.yml
        output: nuclei-output.txt
        json: nuclei-results.json
        sarif: nuclei-results.sarif
        
    - name: Upload Nuclei Results
      uses: github/codeql-action/upload-sarif@v3
      with:
        sarif_file: nuclei-results.sarif
      if: always()
    
    - name: Process Results
      run: |
        # Count vulnerabilities by severity
        critical=$(jq '[.[] | select(.info.severity=="critical")] | length' nuclei-results.json)
        high=$(jq '[.[] | select(.info.severity=="high")] | length' nuclei-results.json)
        medium=$(jq '[.[] | select(.info.severity=="medium")] | length' nuclei-results.json)
        
        echo "CRITICAL_COUNT=$critical" >> $GITHUB_ENV
        echo "HIGH_COUNT=$high" >> $GITHUB_ENV  
        echo "MEDIUM_COUNT=$medium" >> $GITHUB_ENV
        
        # Fail if critical vulnerabilities found
        if [ "$critical" -gt 0 ]; then
          echo "‚ùå Critical vulnerabilities found: $critical"
          exit 1
        fi
        
        if [ "$high" -gt 5 ]; then
          echo "‚ö†Ô∏è Too many high severity vulnerabilities: $high"
          exit 1
        fi
    
    - name: Comment PR
      if: github.event_name == 'pull_request'
      uses: actions/github-script@v7
      with:
        script: |
          const critical = process.env.CRITICAL_COUNT;
          const high = process.env.HIGH_COUNT;
          const medium = process.env.MEDIUM_COUNT;
          
          const comment = `## üîç Nuclei Security Scan Results
          
          **Vulnerability Summary:**
          - üî¥ Critical: ${critical}
          - üü† High: ${high}  
          - üü° Medium: ${medium}
          
          ${critical > 0 ? '‚ùå Critical vulnerabilities must be fixed before merging' : ''}
          ${high > 5 ? '‚ö†Ô∏è High number of high-severity issues detected' : ''}
          ${critical == 0 && high <= 5 ? '‚úÖ Security scan passed' : ''}
          `;
          
          github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: comment
          });
```

### 3. Burp Suite Professional - Advanced Commercial Solution

#### Advanced Configuration

**Burp Suite Project Configuration:**
```json
{
  "project_options": {
    "connections": {
      "platform_authentication": {
        "do_platform_authentication": true,
        "credentials": [
          {
            "username": "test.student@edtech.com",
            "password": "TestPassword123!",
            "domain": "edtech-platform.com",
            "type": "basic"
          }
        ]
      },
      "upstream_proxy": {
        "servers": []
      }
    },
    "http": {
      "redirections": {
        "understand_application_redirections": true,
        "process_application_redirections": "always"
      },
      "streaming_responses": {
        "store_streaming_responses": true,
        "strip_chunked_encoding": true
      }
    },
    "ssl": {
      "negotiate_ssl_connections": "per_host",
      "ignore_failed_ssl_certificate_validation": false
    }
  },
  "target": {
    "scope": {
      "include": [
        {
          "enabled": true,
          "file": "^https://staging\\.edtech-platform\\.com.*$",
          "host": "^staging\\.edtech-platform\\.com$",
          "port": "^443$",
          "protocol": "https"
        }
      ],
      "exclude": [
        {
          "enabled": true,
          "file": "^https://staging\\.edtech-platform\\.com/static/.*$"
        },
        {
          "enabled": true,
          "file": "^https://staging\\.edtech-platform\\.com/assets/.*$"
        }
      ]
    }
  }
}
```

**Custom Burp Extensions for EdTech:**
```python
# burp-extensions/edtech-security-checks.py
from burp import IBurpExtender, IScannerCheck, IScanIssue, IHttpRequestResponse
import re
import json

class BurpExtender(IBurpExtender, IScannerCheck):
    def registerExtenderCallbacks(self, callbacks):
        self._callbacks = callbacks
        self._helpers = callbacks.getHelpers()
        callbacks.setExtensionName("EdTech Security Checker")
        callbacks.registerScannerCheck(self)
        
    def doPassiveScan(self, baseRequestResponse):
        issues = []
        
        # Check for student PII exposure
        pii_issue = self.checkStudentPIIExposure(baseRequestResponse)
        if pii_issue:
            issues.append(pii_issue)
            
        # Check for grade manipulation endpoints
        grade_issue = self.checkGradeManipulation(baseRequestResponse)
        if grade_issue:
            issues.append(grade_issue)
            
        # Check for course access control
        access_issue = self.checkCourseAccessControl(baseRequestResponse)
        if access_issue:
            issues.append(access_issue)
            
        return issues
    
    def doActiveScan(self, baseRequestResponse, insertionPoint):
        issues = []
        
        # Test for SQL injection in grade-related parameters
        if self.isGradeRelatedParameter(insertionPoint):
            sql_issue = self.testSQLInjection(baseRequestResponse, insertionPoint)
            if sql_issue:
                issues.append(sql_issue)
        
        # Test for authorization bypass
        auth_issue = self.testAuthorizationBypass(baseRequestResponse, insertionPoint)
        if auth_issue:
            issues.append(auth_issue)
            
        return issues
    
    def checkStudentPIIExposure(self, baseRequestResponse):
        response = self._helpers.analyzeResponse(baseRequestResponse.getResponse())
        body = baseRequestResponse.getResponse()[response.getBodyOffset():].tostring()
        
        # Check for SSN patterns
        ssn_pattern = r'\b\d{3}-\d{2}-\d{4}\b'
        if re.search(ssn_pattern, body):
            return CustomScanIssue(
                baseRequestResponse.getHttpService(),
                self._helpers.analyzeRequest(baseRequestResponse).getUrl(),
                [baseRequestResponse],
                "Student PII Exposure - SSN",
                "The response contains what appears to be Social Security Numbers",
                "High",
                "Firm"
            )
        
        # Check for student ID patterns in responses
        student_id_pattern = r'"student_id":\s*"\d+'
        if re.search(student_id_pattern, body):
            # Check if this exposes other students' IDs
            return self.validateStudentIDExposure(baseRequestResponse, body)
            
        return None
    
    def checkGradeManipulation(self, baseRequestResponse):
        request = baseRequestResponse.getRequest()
        request_info = self._helpers.analyzeRequest(request)
        
        # Check if this is a grade update endpoint
        url = str(request_info.getUrl())
        if any(keyword in url.lower() for keyword in ['grade', 'score', 'assessment']):
            
            # Check if proper authorization headers are present
            headers = request_info.getHeaders()
            has_auth = any('authorization' in header.lower() for header in headers)
            
            if not has_auth:
                return CustomScanIssue(
                    baseRequestResponse.getHttpService(),
                    request_info.getUrl(),
                    [baseRequestResponse],
                    "Missing Authorization in Grade Endpoint",
                    "Grade-related endpoint lacks proper authorization headers",
                    "Medium",
                    "Firm"
                )
        
        return None

class CustomScanIssue(IScanIssue):
    def __init__(self, httpService, url, httpMessages, name, detail, severity, confidence):
        self._httpService = httpService
        self._url = url
        self._httpMessages = httpMessages
        self._name = name
        self._detail = detail
        self._severity = severity
        self._confidence = confidence
    
    def getUrl(self):
        return self._url
    
    def getIssueName(self):
        return self._name
    
    def getIssueType(self):
        return 0x08000000  # Custom issue type
    
    def getSeverity(self):
        return self._severity
    
    def getConfidence(self):
        return self._confidence
    
    def getIssueBackground(self):
        return "Educational platforms handle sensitive student data and must implement proper security controls."
    
    def getRemediationBackground(self):
        return "Implement proper authorization checks and data protection measures."
    
    def getIssueDetail(self):
        return self._detail
    
    def getRemediationDetail(self):
        return "Review the application's authorization logic and ensure proper access controls are in place."
    
    def getHttpMessages(self):
        return self._httpMessages
    
    def getHttpService(self):
        return self._httpService
```

## üîß Advanced DAST Techniques

### 1. API Security Testing

**OpenAPI/Swagger Integration:**
```yaml
# api-security-tests.yml
openapi: 3.0.3
info:
  title: EdTech Platform API Security Tests
  version: 1.0.0

paths:
  /api/grades/{studentId}:
    get:
      summary: Get student grades
      parameters:
        - name: studentId
          in: path
          required: true
          schema:
            type: string
          # Security test cases
          examples:
            normal:
              value: "student123"
            sql_injection:
              value: "student123'; DROP TABLE grades; --"
            path_traversal:
              value: "../../../etc/passwd"
            authorization_bypass:
              value: "other_student_456"
      security:
        - bearerAuth: []
      responses:
        '200':
          description: Grades retrieved successfully
        '403':
          description: Unauthorized access
        '404':
          description: Student not found

  /api/grades/update:
    post:
      summary: Update student grade
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                student_id:
                  type: string
                course_id:
                  type: string
                grade:
                  type: string
                points:
                  type: number
            # Security test payloads
            examples:
              normal:
                value:
                  student_id: "student123"
                  course_id: "course456"
                  grade: "A"
                  points: 95
              privilege_escalation:
                value:
                  student_id: "other_student"
                  course_id: "premium_course"
                  grade: "A+"
                  points: 100
                  override: true
              injection_test:
                value:
                  student_id: "'; DROP TABLE students; --"
                  course_id: "<script>alert('xss')</script>"
                  grade: "{{7*7}}"  # Template injection
                  points: 999999
```

**Automated API Security Testing:**
```python
# scripts/api-security-tester.py
import requests
import json
import time
from typing import List, Dict
import concurrent.futures

class APISecurityTester:
    def __init__(self, base_url: str, auth_token: str):
        self.base_url = base_url
        self.session = requests.Session()
        self.session.headers.update({
            'Authorization': f'Bearer {auth_token}',
            'Content-Type': 'application/json',
            'User-Agent': 'EdTech-Security-Scanner/1.0'
        })
        
    def test_api_endpoints(self, endpoints: List[Dict]) -> List[Dict]:
        """Test multiple API endpoints concurrently"""
        results = []
        
        with concurrent.futures.ThreadPoolExecutor(max_workers=5) as executor:
            futures = []
            
            for endpoint in endpoints:
                future = executor.submit(self.test_endpoint, endpoint)
                futures.append(future)
                
            for future in concurrent.futures.as_completed(futures):
                result = future.result()
                if result:
                    results.append(result)
                    
        return results
    
    def test_endpoint(self, endpoint: Dict) -> Dict:
        """Test individual endpoint for security vulnerabilities"""
        vulnerabilities = []
        
        # Test for SQL injection
        sql_vulns = self.test_sql_injection(endpoint)
        vulnerabilities.extend(sql_vulns)
        
        # Test for XSS
        xss_vulns = self.test_xss(endpoint)
        vulnerabilities.extend(xss_vulns)
        
        # Test for authorization bypass
        auth_vulns = self.test_authorization_bypass(endpoint)
        vulnerabilities.extend(auth_vulns)
        
        # Test for parameter manipulation
        param_vulns = self.test_parameter_manipulation(endpoint)
        vulnerabilities.extend(param_vulns)
        
        return {
            'endpoint': endpoint,
            'vulnerabilities': vulnerabilities,
            'tested_at': time.time()
        }
    
    def test_sql_injection(self, endpoint: Dict) -> List[Dict]:
        """Test for SQL injection vulnerabilities"""
        sql_payloads = [
            "' OR '1'='1",
            "'; DROP TABLE students; --",
            "' UNION SELECT * FROM users; --",
            "1' AND SLEEP(5) --"
        ]
        
        vulnerabilities = []
        
        for payload in sql_payloads:
            # Test in URL parameters
            if endpoint.get('method') == 'GET':
                test_url = f"{self.base_url}{endpoint['path']}?id={payload}"
                response = self.session.get(test_url)
                
                if self.detect_sql_injection(response, payload):
                    vulnerabilities.append({
                        'type': 'SQL Injection',
                        'severity': 'Critical',
                        'payload': payload,
                        'location': 'URL Parameter',
                        'response_time': response.elapsed.total_seconds()
                    })
            
            # Test in POST body
            elif endpoint.get('method') == 'POST':
                test_data = endpoint.get('test_data', {}).copy()
                for key in test_data:
                    test_data[key] = payload
                    
                response = self.session.post(
                    f"{self.base_url}{endpoint['path']}", 
                    json=test_data
                )
                
                if self.detect_sql_injection(response, payload):
                    vulnerabilities.append({
                        'type': 'SQL Injection',
                        'severity': 'Critical',
                        'payload': payload,
                        'location': f'POST body - {key}',
                        'response_time': response.elapsed.total_seconds()
                    })
        
        return vulnerabilities
    
    def detect_sql_injection(self, response: requests.Response, payload: str) -> bool:
        """Detect SQL injection based on response characteristics"""
        error_indicators = [
            'mysql_fetch_array',
            'ORA-01756',
            'Microsoft OLE DB',
            'SQLServer JDBC Driver',
            'PostgreSQL query failed',
            'syntax error',
            'mysql_num_rows',
            'Warning: mysql_'
        ]
        
        response_text = response.text.lower()
        
        # Check for database error messages
        for indicator in error_indicators:
            if indicator.lower() in response_text:
                return True
        
        # Check for unusual response times (time-based injection)
        if 'sleep' in payload.lower() and response.elapsed.total_seconds() > 4:
            return True
        
        # Check for union-based injection success
        if 'union' in payload.lower() and response.status_code == 200:
            if len(response.text) > 1000:  # Unusually large response
                return True
        
        return False
    
    def test_authorization_bypass(self, endpoint: Dict) -> List[Dict]:
        """Test for authorization bypass vulnerabilities"""
        vulnerabilities = []
        
        # Test without authentication token
        headers_without_auth = self.session.headers.copy()
        del headers_without_auth['Authorization']
        
        response = requests.request(
            endpoint.get('method', 'GET'),
            f"{self.base_url}{endpoint['path']}",
            headers=headers_without_auth,
            json=endpoint.get('test_data')
        )
        
        # Should return 401 or 403, not 200
        if response.status_code == 200:
            vulnerabilities.append({
                'type': 'Authorization Bypass',
                'severity': 'High',
                'description': 'Endpoint accessible without authentication',
                'status_code': response.status_code
            })
        
        # Test with invalid token
        invalid_headers = self.session.headers.copy()
        invalid_headers['Authorization'] = 'Bearer invalid_token_12345'
        
        response = requests.request(
            endpoint.get('method', 'GET'),
            f"{self.base_url}{endpoint['path']}",
            headers=invalid_headers,
            json=endpoint.get('test_data')
        )
        
        if response.status_code == 200:
            vulnerabilities.append({
                'type': 'Authorization Bypass',
                'severity': 'High',
                'description': 'Endpoint accessible with invalid token',
                'status_code': response.status_code
            })
        
        return vulnerabilities
    
    def generate_report(self, results: List[Dict]) -> str:
        """Generate security report"""
        total_endpoints = len(results)
        total_vulnerabilities = sum(len(r['vulnerabilities']) for r in results)
        
        critical_count = sum(1 for r in results for v in r['vulnerabilities'] if v.get('severity') == 'Critical')
        high_count = sum(1 for r in results for v in r['vulnerabilities'] if v.get('severity') == 'High')
        medium_count = sum(1 for r in results for v in r['vulnerabilities'] if v.get('severity') == 'Medium')
        
        report = f"""
# API Security Testing Report

## Summary
- **Endpoints Tested**: {total_endpoints}
- **Total Vulnerabilities**: {total_vulnerabilities}
- **Critical**: {critical_count}
- **High**: {high_count}  
- **Medium**: {medium_count}

## Detailed Findings
"""
        
        for result in results:
            if result['vulnerabilities']:
                report += f"\n### {result['endpoint']['path']}\n"
                for vuln in result['vulnerabilities']:
                    report += f"- **{vuln['type']}** ({vuln['severity']}): {vuln.get('description', 'No description')}\n"
        
        return report

# Usage example
if __name__ == "__main__":
    tester = APISecurityTester(
        base_url="https://staging.edtech-platform.com",
        auth_token="your_test_token_here"
    )
    
    endpoints = [
        {
            'path': '/api/grades/student123',
            'method': 'GET'
        },
        {
            'path': '/api/grades/update',
            'method': 'POST',
            'test_data': {
                'student_id': 'student123',
                'course_id': 'course456',
                'grade': 'A',
                'points': 95
            }
        }
    ]
    
    results = tester.test_api_endpoints(endpoints)
    report = tester.generate_report(results)
    
    with open('api-security-report.md', 'w') as f:
        f.write(report)
```

### 2. Business Logic Testing

**Automated Business Logic Tests:**
```python
# scripts/business-logic-tester.py
class EdTechBusinessLogicTester:
    def __init__(self, base_url: str, auth_tokens: Dict[str, str]):
        self.base_url = base_url
        self.auth_tokens = auth_tokens  # Different user roles
        
    def test_grade_modification_logic(self):
        """Test grade modification business logic"""
        tests = []
        
        # Test 1: Student trying to modify their own grade
        student_session = self.create_session('student')
        result = student_session.post(f"{self.base_url}/api/grades/update", json={
            'student_id': 'current_student',
            'course_id': 'math101',
            'grade': 'A+',
            'points': 100
        })
        
        if result.status_code == 200:
            tests.append({
                'test': 'Student Self-Grade Modification',
                'status': 'FAIL',
                'severity': 'High',
                'description': 'Students should not be able to modify their own grades'
            })
        
        # Test 2: Teacher modifying grade for wrong class
        teacher_session = self.create_session('teacher')
        result = teacher_session.post(f"{self.base_url}/api/grades/update", json={
            'student_id': 'student_not_in_class',
            'course_id': 'unauthorized_course',
            'grade': 'A',
            'points': 95
        })
        
        if result.status_code == 200:
            tests.append({
                'test': 'Cross-Class Grade Modification',
                'status': 'FAIL',
                'severity': 'High',
                'description': 'Teachers should only modify grades for their own classes'
            })
        
        # Test 3: Grade value validation
        result = teacher_session.post(f"{self.base_url}/api/grades/update", json={
            'student_id': 'valid_student',
            'course_id': 'valid_course',
            'grade': 'A+++',  # Invalid grade
            'points': 999999  # Invalid points
        })
        
        if result.status_code == 200:
            tests.append({
                'test': 'Invalid Grade Value Acceptance',
                'status': 'FAIL',
                'severity': 'Medium',
                'description': 'System accepts invalid grade values'
            })
        
        return tests
    
    def test_course_enrollment_logic(self):
        """Test course enrollment business logic"""
        tests = []
        
        # Test 1: Double enrollment
        student_session = self.create_session('student')
        
        # Enroll once
        first_enrollment = student_session.post(f"{self.base_url}/api/courses/enroll", json={
            'course_id': 'premium_course_123'
        })
        
        # Try to enroll again
        second_enrollment = student_session.post(f"{self.base_url}/api/courses/enroll", json={
            'course_id': 'premium_course_123'
        })
        
        if second_enrollment.status_code == 200:
            tests.append({
                'test': 'Double Enrollment Prevention',
                'status': 'FAIL',
                'severity': 'Medium',
                'description': 'System allows multiple enrollments in same course'
            })
        
        # Test 2: Free user accessing premium content
        free_user_session = self.create_session('free_user')
        premium_access = free_user_session.get(f"{self.base_url}/api/courses/premium_course_123/content")
        
        if premium_access.status_code == 200:
            tests.append({
                'test': 'Premium Content Access Control',
                'status': 'FAIL',
                'severity': 'High',
                'description': 'Free users can access premium content'
            })
        
        return tests
    
    def test_payment_logic(self):
        """Test payment processing business logic"""
        tests = []
        
        # Test 1: Negative amount payments
        user_session = self.create_session('student')
        payment_result = user_session.post(f"{self.base_url}/api/payments/process", json={
            'amount': -100,  # Negative amount
            'course_id': 'premium_course',
            'payment_method': 'credit_card'
        })
        
        if payment_result.status_code == 200:
            tests.append({
                'test': 'Negative Payment Amount',
                'status': 'FAIL',
                'severity': 'Critical',
                'description': 'System accepts negative payment amounts'
            })
        
        # Test 2: Zero amount payments for premium courses
        zero_payment = user_session.post(f"{self.base_url}/api/payments/process", json={
            'amount': 0,
            'course_id': 'premium_course',
            'payment_method': 'credit_card'
        })
        
        if zero_payment.status_code == 200:
            tests.append({
                'test': 'Zero Amount Premium Payment',
                'status': 'FAIL',
                'severity': 'High',
                'description': 'Premium courses can be purchased with zero payment'
            })
        
        return tests
```

## üìä DAST Performance and Reporting

### Comprehensive Reporting System

```python
# scripts/dast-report-generator.py
import json
import datetime
from jinja2 import Template

class DASTReportGenerator:
    def __init__(self):
        self.report_template = """
# DAST Security Assessment Report

**Generated**: {{ report_date }}  
**Target**: {{ target_url }}  
**Scan Duration**: {{ scan_duration }} minutes  
**Scanner**: {{ scanner_name }}

## Executive Summary

### Vulnerability Summary
- **Critical**: {{ vulnerabilities.critical }} üî¥
- **High**: {{ vulnerabilities.high }} üü†  
- **Medium**: {{ vulnerabilities.medium }} üü°
- **Low**: {{ vulnerabilities.low }} üü¢
- **Info**: {{ vulnerabilities.info }} ‚ÑπÔ∏è

**Total Issues**: {{ vulnerabilities.total }}

### Risk Assessment
{% if vulnerabilities.critical > 0 %}
üö® **CRITICAL**: Immediate action required. {{ vulnerabilities.critical }} critical vulnerabilities detected.
{% elif vulnerabilities.high > 5 %}
‚ö†Ô∏è **HIGH RISK**: {{ vulnerabilities.high }} high-severity vulnerabilities require urgent attention.
{% elif vulnerabilities.medium > 10 %}
‚ö†Ô∏è **MEDIUM RISK**: {{ vulnerabilities.medium }} medium-severity issues should be addressed soon.
{% else %}
‚úÖ **LOW RISK**: Security posture is acceptable with minor issues to address.
{% endif %}

## Detailed Findings

{% for vuln in detailed_vulnerabilities %}
### {{ vuln.name }} ({{ vuln.severity }})

**Description**: {{ vuln.description }}  
**Impact**: {{ vuln.impact }}  
**URL**: {{ vuln.url }}  
**Parameter**: {{ vuln.parameter }}  

**Evidence**:
```
{{ vuln.evidence }}
```

**Remediation**:
{{ vuln.remediation }}

**References**:
{% for ref in vuln.references %}
- [{{ ref.title }}]({{ ref.url }})
{% endfor %}

---
{% endfor %}

## OWASP Top 10 Coverage

{% for owasp_item in owasp_coverage %}
- **{{ owasp_item.id }}**: {{ owasp_item.name }} - {% if owasp_item.tested %}‚úÖ Tested{% else %}‚ùå Not Tested{% endif %}
{% endfor %}

## Compliance Status

### GDPR Compliance
{% if gdpr_issues|length > 0 %}
‚ùå **Issues Found**: {{ gdpr_issues|length }} GDPR-related vulnerabilities detected
{% for issue in gdpr_issues %}
- {{ issue.description }}
{% endfor %}
{% else %}
‚úÖ **Compliant**: No GDPR-related vulnerabilities detected
{% endif %}

### FERPA Compliance (Educational Records)
{% if ferpa_issues|length > 0 %}
‚ùå **Issues Found**: {{ ferpa_issues|length }} FERPA-related vulnerabilities detected
{% for issue in ferpa_issues %}
- {{ issue.description }}
{% endfor %}
{% else %}
‚úÖ **Compliant**: No FERPA-related vulnerabilities detected
{% endif %}

## Recommendations

### Immediate Actions (0-1 weeks)
{% for action in immediate_actions %}
- {{ action }}
{% endfor %}

### Short-term Actions (1-4 weeks)  
{% for action in short_term_actions %}
- {{ action }}
{% endfor %}

### Long-term Actions (1-3 months)
{% for action in long_term_actions %}
- {{ action }}
{% endfor %}

## Testing Methodology

**Scope**: {{ methodology.scope }}  
**Authentication**: {{ methodology.authentication }}  
**Testing Approach**: {{ methodology.approach }}  
**Exclusions**: {{ methodology.exclusions }}

## Appendix

### Test Coverage
- **Pages Scanned**: {{ coverage.pages_scanned }}
- **Forms Tested**: {{ coverage.forms_tested }}  
- **Parameters Analyzed**: {{ coverage.parameters_analyzed }}
- **APIs Tested**: {{ coverage.apis_tested }}

### Scan Configuration
```yaml
{{ scan_configuration }}
```
        """
    
    def generate_report(self, scan_results: Dict) -> str:
        """Generate comprehensive DAST report"""
        
        # Process vulnerabilities
        vulnerabilities = self.process_vulnerabilities(scan_results.get('vulnerabilities', []))
        
        # Generate OWASP Top 10 coverage
        owasp_coverage = self.generate_owasp_coverage(vulnerabilities)
        
        # Generate compliance analysis
        gdpr_issues = self.analyze_gdpr_compliance(vulnerabilities)
        ferpa_issues = self.analyze_ferpa_compliance(vulnerabilities)
        
        # Generate recommendations
        recommendations = self.generate_recommendations(vulnerabilities)
        
        template = Template(self.report_template)
        
        return template.render(
            report_date=datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            target_url=scan_results.get('target_url', 'Unknown'),
            scan_duration=scan_results.get('duration_minutes', 0),
            scanner_name=scan_results.get('scanner', 'Unknown'),
            vulnerabilities=vulnerabilities['summary'],
            detailed_vulnerabilities=vulnerabilities['detailed'],
            owasp_coverage=owasp_coverage,
            gdpr_issues=gdpr_issues,
            ferpa_issues=ferpa_issues,
            immediate_actions=recommendations['immediate'],
            short_term_actions=recommendations['short_term'],
            long_term_actions=recommendations['long_term'],
            methodology=scan_results.get('methodology', {}),
            coverage=scan_results.get('coverage', {}),
            scan_configuration=scan_results.get('configuration', {})
        )
    
    def process_vulnerabilities(self, raw_vulnerabilities: List[Dict]) -> Dict:
        """Process and categorize vulnerabilities"""
        summary = {
            'critical': 0,
            'high': 0,
            'medium': 0,
            'low': 0,
            'info': 0,
            'total': len(raw_vulnerabilities)
        }
        
        detailed = []
        
        for vuln in raw_vulnerabilities:
            severity = vuln.get('severity', 'info').lower()
            summary[severity] = summary.get(severity, 0) + 1
            
            detailed.append({
                'name': vuln.get('name', 'Unknown Vulnerability'),
                'severity': severity.upper(),
                'description': vuln.get('description', 'No description available'),
                'impact': vuln.get('impact', 'Unknown impact'),
                'url': vuln.get('url', ''),
                'parameter': vuln.get('parameter', ''),
                'evidence': vuln.get('evidence', ''),
                'remediation': vuln.get('solution', 'No remediation provided'),
                'references': vuln.get('references', [])
            })
        
        return {
            'summary': summary,
            'detailed': detailed
        }
    
    def generate_owasp_coverage(self, vulnerabilities: Dict) -> List[Dict]:
        """Generate OWASP Top 10 coverage analysis"""
        owasp_top_10 = [
            {'id': 'A01:2021', 'name': 'Broken Access Control', 'tested': False},
            {'id': 'A02:2021', 'name': 'Cryptographic Failures', 'tested': False},
            {'id': 'A03:2021', 'name': 'Injection', 'tested': False},
            {'id': 'A04:2021', 'name': 'Insecure Design', 'tested': False},
            {'id': 'A05:2021', 'name': 'Security Misconfiguration', 'tested': False},
            {'id': 'A06:2021', 'name': 'Vulnerable Components', 'tested': False},
            {'id': 'A07:2021', 'name': 'Identification and Authentication Failures', 'tested': False},
            {'id': 'A08:2021', 'name': 'Software and Data Integrity Failures', 'tested': False},
            {'id': 'A09:2021', 'name': 'Security Logging and Monitoring Failures', 'tested': False},
            {'id': 'A10:2021', 'name': 'Server-Side Request Forgery', 'tested': False}
        ]
        
        # Mark as tested based on vulnerability types found
        vulnerability_names = [v['name'].lower() for v in vulnerabilities['detailed']]
        
        for item in owasp_top_10:
            item_name = item['name'].lower()
            if any(keyword in ' '.join(vulnerability_names) for keyword in item_name.split()):
                item['tested'] = True
        
        return owasp_top_10
```

---

## Navigation

| Previous | Next |
|----------|------|
| [‚Üê SAST Analysis](./sast-analysis.md) | [Dependency Scanning ‚Üí](./dependency-scanning.md) |

### Related Documents
- üîß [Implementation Guide](./implementation-guide.md)
- üèÜ [Best Practices](./best-practices.md)
- üìä [Comparison Analysis](./comparison-analysis.md)
- üí∞ [Cost Analysis](./cost-analysis.md)